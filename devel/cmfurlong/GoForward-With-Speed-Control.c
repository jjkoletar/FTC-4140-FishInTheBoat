#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     HTSMUX,              sensorLowSpeed)
#pragma config(Motor,  mtr_S1_C2_1,     leftMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightMotor,    tmotorNormal, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C1_1,    shoulderServo,        tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    wristServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    handServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo8,               tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo7,               tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    ,                     tServoStandard)
#pragma config(SrvoPosition,  Position01,            128, 128, 255, 255, 128, 128, 128, 128)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "FITBIncludes.c" //Include multi-purpose custom functions
#include "HTGYRO-driver.h"

/*   ---FTC--Fish in the Boat Team 4140--Written for CaptureBot v1--

This is a basic drive control, written from scratch after previous code (Joystick2-modified.c) was too trashed to work on the robot, along with the re-design of the motors.

///Log\\\
*Wrote basic drive control, and dead zone function. - 10/21/10 JJK




///Notes\\\
*Having the rightMotor be postitive power, and the leftMotor be negative power makes the robot go forward. - 10/21/10 JJK








*/


/*
You're entering the variable declaration zone!
*/
int whatJoystick, deadZone, leftSpeedFactor, rightSpeedFactor, globalSpeedConstant, deadZoneResult;
int speedControlAmounts[3];
int savedHand = 0, savedElbow = 0, savedShoulder = 0, savedHip = 0;
bool coast;

/*
Goodbye from the variable declaration zone!
*/
void defineVariables()
{
  /*
  Config Zone!
  */
  servoChangeRate[handServo] = 7;
  servoChangeRate[shoulderServo] = 7;
  deadZone = 10; //The amount the joystick must be greater than for the values to be used, and not be zero.
  speedControlAmounts[0] = 1; //Speed Control Factors.
  speedControlAmounts[1] = 2;
  speedControlAmounts[2] = 3;
  leftSpeedFactor = 0; //Write default power for left motor.
  rightSpeedFactor = 0; //Write default power for right motor.
  globalSpeedConstant = 2;
  //Always coast when in dead zone?
  coast = true;

  /*
  End Config Zone!
  */
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  defineVariables(); //Fix for defining config bugs
  HTSMUXinit();//           Init sensor Muxer
  HTSMUXscanPorts(HTSMUX);//^^^^^^^^^^^^^^^^^
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int makeJoystickValuesWithDeadZone (int joyNum)
{
  if (coast)
  {
    deadZoneResult = 1;
  }
  else
  {
    deadZoneResult = 0;
  }
  if (joyNum==1)
  {
    whatJoystick = joystick.joy1_y2;
  }
  else if (joyNum==2)
  {
    whatJoystick = joystick.joy1_y1;
  }
  if (whatJoystick<deadZone)
  {
    if (whatJoystick>-deadZone)
    {
      whatJoystick = deadZoneResult;
    }

  }
  return whatJoystick/globalSpeedConstant;
}

void savePos()
{
  savedHand = servo[handServo];
  //savedElbow = servo[elbowServo];
  savedShoulder = servo[shoulderServo];
  //savedHip = servo[hipServo];
}



void moveArm(int position, string height)
{
  if (position==1 && height=="tall")
  {
    servo[shoulderServo] = 181;
    servo[wristServo] = 97;
    servo[handServo] = 14
  }
  else if (position==2 && height=="tall")
  {
    servo[shoulderServo] = 181;
    servo[wristServo] = 97;
    servo[handServo] = 255;

  }
  else if (position==1 && height=="medium")
  {
   servo[handServo] = 14;
   servo[shoulderServo] = 217;
   servo[wristServo] = 67;
  }

  else if (position==2 && height=="medium")
  {
   servo[handServo] = 255;
   servo[shoulderServo] = 217;
   servo[wristServo] = 67;

  }
  else if (position==3)
  {
    servo[shoulderServo] = 47;
    servo[wristServo] = 114;
    servo[handServo] = 255;
  }
  else if (position==4)
  {
    servo[shoulderServo] = 47;
    servo[wristServo] = 114;
    wait10Msec(20);
    servo[handServo] = 14;
  }

}
void armSys(string sys, string height="tall")
{
  if (sys=="togoal")
  {
    moveArm(1, height);
    wait10Msec(100);
    moveArm(2, height);
    wait10Msec(100);
    moveArm(3, height);
    wait10Msec(150);
    moveArm(4, height);
    wait10Msec(100);
  }
}

void parseSpeedControlActions()
{
  /*
  Button: *5 = Left Motor Up
          *6 = Right Motor Up
          *7 = Left Motor Down
          *8 = Right Motor Down
  */
  if (joyButton("bumped", 5))
  {
    leftSpeedFactor = leftSpeedFactor+1;
  }
  else if (joyButton("bumped", 7))
  {
    leftSpeedFactor = leftSpeedFactor-1;
  }
  else if (joyButton("bumped", 6))
  {
    rightSpeedFactor = rightSpeedFactor+1;
  }
  else if (joyButton("bumped", 8))
  {
    rightSpeedFactor = rightSpeedFactor-1;
  }
 //Check for sanity, keeping upper and lower limits in place.
  if (leftSpeedFactor>=2)
  {
    leftSpeedFactor = 2;
  }
  else if (leftSpeedFactor<=0)
  {
    leftSpeedFactor = 0;
  }
  if (rightSpeedFactor>=2)
  {
    rightSpeedFactor = 2;
  }
  else if (rightSpeedFactor<=0)
  {
    rightSpeedFactor = 0;
  }
}

void makeJoystickValues()
{
  //parse both joysticks into a single power and direction


}

void driveWithPoolFunctionality()
{
  //adjust pool size
  int pool;
  pool = pool * (joystick.joy1_y2/100);
  //distribute pool to each motor
  int finalLeft, finalRight;
  //-128  = all left
  //128  = all right
  if (joystick.joy1_x1 < 0)
  {
    //turning left
    finalLeft = abs(joystick.joy1_x1)/128;
    finalRight = ((finalLeft*128)-128)/128;
  }

  //Send to motors
  motor[leftMotor] = finalLeft;
  motor[rightMotor] = finalRight;
}





task main()
{
  initializeRobot();



  waitForStart();   // wait for start of tele-op phase

  while (true)
  {
    getJoystickSettings(joystick);
    motor[rightMotor] = makeJoystickValuesWithDeadZone(2);
    motor[leftMotor] = makeJoystickValuesWithDeadZone(1);
    //driveWithPoolFunctionality();
    parseSpeedControlActions();
    eraseDisplay();
    nxtDisplayStringAt(0,100,"Left: %d Right: %d", motor[leftMotor], motor[rightMotor]);
    if (joystick.joy1_TopHat == 2)
    {
      //nudge right
      //right back, back, periouette left, forward, left forward
      motor[rightMotor] = -15;
      wait1Msec(500);
      motor[leftMotor] = -15;
      wait1Msec(500);
      motor[rightMotor] = 15;
      wait1Msec(500);
      motor[leftMotor] = 15;
      wait1Msec(500);
      motor[rightMotor] = 30;
      wait1Msec(500);
      float aligned;
      aligned = 0;
      while (aligned!=1)
      {
        //if (SensorValue(leftTouch)==0)
        //{
        //  motor[leftMotor] = 15;
        //}
        //else
        //{
        //  motor[leftMotor] = 1;
        //  aligned = aligned+0.5;
        //}
        //if (SensorValue(rightTouch)==0)
        //{
        //  motor[rightMotor] = 15;
        //}
        //else
        //{
        //  motor[rightMotor] = 1;
        //  aligned = aligned+0.5;
        //}
      }
      motor[leftMotor] = 1;
      motor[rightMotor] = 1;
      //Please work!!!!!
    }
    if (joy1Btn(5))
    {
      //nudge left
    }
    if (joy1Btn(1))
    {
      moveArm(1, "medium");
    }
    if (joy1Btn(2))
    {
      moveArm(2, "medium");
    }
    if (joy1Btn(3))
    {
      moveArm(3, "medium");
    }
    if (joy1Btn(4))
    {
      moveArm(4, "medium");
    }
    if (joy1Btn(10))
    {
      armSys("togoal", "medium");
    }
    if (joy1Btn(9))
    {
      bool autopilotDone = false;
      int loopsDone = 0;
      while (!autopilotDone)
      {
        armSys("togoal", "medium");
        ++loopsDone;
        if (joy1Btn(8) || loopsDone >= 15)
        { autopilotDone = true; }

      }

    }

    }
  }
