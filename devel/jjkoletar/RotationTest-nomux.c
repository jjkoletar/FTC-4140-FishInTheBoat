#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     HTSMUX,              sensorI2CCustom)
#pragma config(Sensor, S3,     rotationLeft,        sensorRotation)
#pragma config(Sensor, S4,     rotationRight,       sensorRotation)
#pragma config(Motor,  mtr_S1_C2_1,     leftMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightMotor,    tmotorNormal, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C1_1,    shoulderServo,        tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    wristServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    handServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo8,               tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo7,               tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    ,                     tServoStandard)
#pragma config(SrvoPosition,  Position01,            128, 128, 255, 255, 128, 128, 128, 128)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "FITBIncludes.c" //Include multi-purpose custom functions
//#include "HTGYRO-driver.h"

//Program Used for Testing legacy rotation sensors
//0.3925   = 1 klick
//1ft = =2.5 in too far
task main()
{
  move(12, 20, "forward", "coast");
/*
  sensorValue[rotationLeft] = 0;
  sensorValue[rotationRight] = 0;
  while (SensorValue[rotationLeft] > -93 && SensorValue[rotationRight] > -93)
  {
  motor[rightMotor] = 20;
  motor[leftMotor] = 20;
}
motor[leftMotor] = 0;
motor[rightMotor] = 0;*/
    while (true)
    {

    //getJoystickSettings(joystick);
    //motor[rightMotor] = makeJoystickValuesWithDeadZone(2);
    //motor[leftMotor] = makeJoystickValuesWithDeadZone(1);
    eraseDisplay();
    nxtDisplayStringAt(0,10,"L: %d R: %d", sensorValue[rotationLeft], sensorValue[rotationRight]);
    wait1Msec(10);

    }


}
