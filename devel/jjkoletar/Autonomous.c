#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTSMUX,              sensorI2CCustom)
#pragma config(Sensor, S3,     gyro,                sensorSONAR)
#pragma config(Sensor, S4,     us,                  sensorSONAR)
#pragma config(Motor,  motorA,          red,           tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          green,         tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          yellow,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     conveyorArmMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     conveyorMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     leftMotor,     tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     rightMotor,    tmotorNormal, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    rightArm,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    leftArm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    preloadServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    possessionServo,      tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    leftGoalHolder,       tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    ,                     tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    frontUS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    rearUS,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

---FTC--Fish in the Boat Team 4140--Autonomous Program--

THIS CODE IS LICENSED UNDER THE GNU GPL v3, INCLUDED IN THE SVN, AND AT THE LINK: http://www.gnu.org/licenses/gpl-3.0.txt
NO WARRANTY PROVIDED.
© FTC 4140 Fish in the Boat and Jeremy Koletar
*/





/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an Tetrix robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "LEGOLS-driver.h"
#include "FITBIncludes.c"
bool sensorDebug = true;
bool rightSide = false;
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
    HTSMUXinit();//           Init sensor Muxer
	  HTSMUXscanPorts(HTSMUX);//^^^^^^^^^^^^^^^^^
	  //init more sensors on the muxer
	  LSsetActive(msensor_S2_3); //init goal grabbed lsensor
	  LSsetActive(msensor_S2_2); //init lsensor on the bridge arm
    servo[preloadServo] =   255;
    servo[leftArm] =  255;
    servo[leftGoalHolder] = 190;
    servo[rightArm] =    10;
    servo[possessionServo] = 0;
}
  //Ultrasound is on Mux2

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void watchPreloads()
{
  int indx = 0;
  while (indx != 10)
  {
    if (LSvalNorm(msensor_S2_3) >= 50) servo[preloadServo] = 50;
    else if (LSvalNorm(msensor_S2_3) > 30) servo[leftGoalHolder] = 160;
    else servo[leftGoalHolder] = 207; servo[preloadServo] = 255;
    ++indx;
  }
}
void usLights()
{
  string colorA = "";
  if (SensorValue[S4] == 255) colorA = "all";
  else if (SensorValue[S4] < 30) colorA = "red";
  else if (SensorValue[S4] >= 30 && SensorValue[S4] <= 31) colorA = "green";
  else if (SensorValue[S4] > 32) colorA = "yellow";
  light(colorA);
  //if (LSvalNorm(msensor_S2_2) >= whiteTape)
  //{
    //setBlink(colorA);
  //}
}
void trigMove()
{
     string s;

    if (SensorValue[S4] < 30) s = "right";
    else if (SensorValue[S4] >= 30) s = "left";
    servo[frontUS] = SensorValue[S3];
    int move = (abs(30-SensorValue[S4])/sinDegrees(20));
    turnDegrees(30, s, 20);
    //(40-SensorValue[S4])/sinDegrees(20)
    moveDist(25, move);
  }

  int forwardToGoal()
  {
    nMotorEncoder[rightMotor] = 0;
    servo[leftArm] = 10;
    servo[rightArm] = 245;
    bool inCave = false;
    const float length = 250;
    const int speed = 20;
    ClearTimer(T2);
    motor[leftMotor] = speed;
    motor[rightMotor] = speed;
    int lengthC = ceil(((length-5)/31.9185813)*1440);
    while (abs(nMotorEncoder[rightMotor]) <= abs(lengthC) && !inCave && time1[T2] < 10000) {
      if (innerTS()) inCave = true;
    }
  //pack
  servo[leftGoalHolder] = 160;
  if (innerTS()) servo[preloadServo] = 50;
  servo[rightArm] =    0;
  servo[leftArm] =  255;
  while (abs(nMotorEncoder[rightMotor]) <= ceil(((130-5)/31.9185813)*1440)) {
  }
  motor[leftMotor] = 0;
  motor[rightMotor] = 0;
  servo[leftGoalHolder] = 191;
  int finalDist = ceil((nMotorEncoder[rightMotor]/1440)*31.9185813)+5;
  nMotorEncoder[rightMotor] = 0;
  return finalDist;
}
void getToBridge()
{
      int dist;
    dist = forwardToGoal();
    moveDist(-30, 45);
    wait1Msec(300);
    turnDegrees(30, "right", 60);
    wait1Msec(250);
    straightForTime(30, 1000);
}
float fAngle()
{
  return radiansToDegrees(asin((abs((SensorValue[S3]+2.0)-SensorValue[S4])/18.0)));
}

void promptForSide()
{
  eraseDisplay();
  nxtDisplayString(3, "Press Side");
  bool done = false;
  while (!done)
  {
    if (nNxtButtonPressed == 1)
    {
      //chose right side
      rightSide = true;
      done = true;
    }
    else if (nNxtButtonPressed == 2)
    {
      //chose left side
      rightSide = false;
      done = true;
    }
  }
}
  void paralellTurn()
  {
        float angle;
    string s;
    const int usOffset = 2;
    bool error = false;
    while (SensorValue[S3]+usOffset != SensorValue[S4] && !error)
    {
    angle = fAngle();
    if (SensorValue[S3]+usOffset < SensorValue[S4]) s = "right";
    else if (SensorValue[S3]+usOffset > SensorValue[S4]) s = "left";
    else s = "none";
    //ceil(angle/2)
    if (SensorValue[S3] >= 100 || SensorValue[S4] >= 100)
    {
      error = true;
      PlayTone(1000, 150);
   }
    else turnDegrees(30, s, angle);
    wait1Msec(500);
  }

}
void forwardToWhite()
{
  nMotorEncoder[leftMotor] = 0;
        const int gray = LSvalNorm(msensor_S2_2)+4;
      motor[leftMotor] = 12;
      motor[rightMotor] = 12;
      ClearTimer(T3);
      while (LSvalNorm(msensor_S2_2) < gray && nMotorEncoder[leftMotor] <= ceil((((80)-5)/31.9185813)*1440) && time1[T3] < 3000 ) {
      }
      motor[leftMotor] = 0;
      motor[rightMotor] = 0;
      nMotorEncoder[leftMotor] = 0;
    }

//moveDist([left]power, length, [right]power, coast);
task main()
{
  initializeRobot();
  //promptForSide();
  waitForStart(); // Wait for the beginning of autonomous phase.
  //turnDeg(40, "left", 40);
  //SensorValue[S4] >= 200

  if (true)
  {
    //paralellWall();
    //jogAlign();
    /*asin((((SensorValue[S3]+1)-SensorValue[S4])/18))*/
    //if (!abs(SensorValue[S4]-SensorValue[S3])>=10)
   //{
    /*
    !!!
    Trig Turn Code
    !!! */
    //for (int indx = 0; indx != 3; indx++)
    //{


      //trigMove();
     // wait1Msec(300);
      //paralellTurn();
     // wait1Msec(500);
    straightForTime(30, 1000);
    wait1Msec(300);
    //back off wall
    moveDist(-20, /*!!X!!!*/27);
    wait1Msec(300);
    turnDegrees(30, "right", 90);
    wait1Msec(300);
    paralellTurn();
    wait1Msec(300);
    /*moveDist(-30, 50);
    wait1Msec(300);
    trigMove();
    wait1Msec(300);
    paralellTurn();*/
    wait1Msec(500);
    forwardToWhite();
  //}

    int leftEn = 0;
    int rightEn = 0;

    while (true)
  {
    usLights();
    servo[frontUS] = SensorValue[S3];
    servo[rearUS]  = SensorValue[S4];
    eraseDisplay();
    nxtDisplayString(5, "LE: %d RE: %d", leftEn, rightEn);
    nxtDisplayString(4, "RUS: %d FUS: %d", SensorValue[S4], SensorValue[S3]);
    nxtDisplayString(3, "BLS: %d", LSvalNorm(msensor_S2_2);
    nxtDisplayString(2, "CAngle: %d", fAngle());
    leftEn = nMotorEncoder[leftMotor];
    rightEn = nMotorEncoder[rightMotor];
    wait1Msec(50);
  }
}
  if (rightSide)
  {
    getToBridge();
    wait1Msec(200);
    moveDist(-30, 10);
    wait1Msec(150);
    servo[rightArm] = 255;
    servo[leftArm]  = 0;
    wait1Msec(1000);
    moveDist(30, 100);
    servo[leftArm] = 255;
    servo[rightArm] = 0;
    moveDist(30, 115);
}
else if (!rightSide)
{
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor]  = 0;
    servo[leftArm] = 10;
    servo[rightArm] = 245;
    bool inCave = false;
    const float length = 250;
    const int speed = 20;
    ClearTimer(T2);
    motor[leftMotor] = speed;
    motor[rightMotor] = speed;
    int lengthC = ceil(((length-5)/31.9185813)*1440);
    while (abs(nMotorEncoder[rightMotor]) <= abs(lengthC) && !inCave && time1[T2] < 10000) {
      if (innerTS()) inCave = true;
    }
    //pack
    servo[leftGoalHolder] = 160;
    if (innerTS()) servo[preloadServo] = 50;
    servo[rightArm] =    0;
    servo[leftArm] =  255;
    while (abs(nMotorEncoder[rightMotor]) <= ceil(((130-5)/31.9185813)*1440)) {
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    servo[leftGoalHolder] = 191;
    int finalDist = ceil((nMotorEncoder[rightMotor]/1440)*31.9185813)+5;
    nMotorEncoder[rightMotor] = 0;
    moveDist(-30, 45);
    wait1Msec(300);
    turnDegrees(30, "left", 60);
    wait1Msec(250);
    straightForTime(30, 1000);
    wait1Msec(200);
    moveDist(-30, 10);
    wait1Msec(150);
    //depress bridge
    servo[rightArm] = 255;
    servo[leftArm]  = 0;
    wait1Msec(1000);
    moveDist(30, 100);
    //raise arms back up halfway on bridge
    servo[leftArm] = 255;
    servo[rightArm] = 10;
    //walk off bridge
    moveDist(30, 115);
    wait1Msec(300);
    //smack into wall
    straightForTime(30, 1000);
    wait1Msec(300);
    //back off wall
    moveDist(-30, /*!!X!!!*/27);
    wait1Msec(300);
    turnDegrees(30, "right", 90);
    wait1Msec(300);
    paralellTurn();
    wait1Msec(300);
    /*moveDist(-30, 50);
    wait1Msec(300);
    trigMove();
    wait1Msec(300);
    paralellTurn();*/
    wait1Msec(500);
    forwardToWhite();
}

}
