#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTSMUX,              sensorI2CCustom)
#pragma config(Sensor, S3,     front,               sensorSONAR)
#pragma config(Sensor, S4,     back,                sensorSONAR)
#pragma config(Motor,  motorA,          preloadMotor,  tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          flapMotor,     tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          sideLight,     tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     conveyorMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     conveyorArmMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftMotor,     tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     rightMotor,    tmotorNormal, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    rightArm,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    leftArm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    preloadServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    possessionServo,      tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    leftGoalHolder,       tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    clawServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    frontUS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    rearUS,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    ,                     tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*


---FTC--Fish in the Boat Team 4140--Autonomous Program--

THIS CODE IS LICENSED UNDER THE GNU GPL v3, INCLUDED IN THE SVN, AND AT THE LINK: http://www.gnu.org/licenses/gpl-3.0.txt
NO WARRANTY PROVIDED.
© FTC 4140 Fish in the Boat and Jeremy Koletar

*/





/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an Tetrix robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "LEGOLS-driver.h"
#include "FITBIncludes.c"
bool sensorDebug = true;
bool rightSide = false;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
    HTSMUXinit();//           Init sensor Muxer
	  HTSMUXscanPorts(HTSMUX);//^^^^^^^^^^^^^^^^^
	  //init more sensors on the muxer
	  LSsetActive(msensor_S2_3); //init goal grabbed lsensor
	  LSsetActive(msensor_S2_2); //init lsensor on the bridge arm
    servo[leftArm] =  255;
    servo[leftGoalHolder] = 190;
    servo[rightArm] =    0;
    servo[possessionServo] = 0;
    servo[clawServo] = 87;
    servo[preloadServo] = 185;
    bFloatDuringInactiveMotorPWM = false;
    nMotorEncoder[conveyorArmMotor] = 0;
    writeDebugStreamLine("[INFO] Init done");
}
  //Ultrasound is on Mux2

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void trigMove()
{
     string s;

    if (SensorValue[S4] < 30) s = "right";
    else if (SensorValue[S4] >= 30) s = "left";
    servo[frontUS] = SensorValue[S3];
    int move = (abs(30-SensorValue[S4])/sinDegrees(20));
    turnDegrees(30, s, 20);
    //(40-SensorValue[S4])/sinDegrees(20)
    moveDist(25, move);
  }

  int forwardToGoal()
  {
    nMotorEncoder[rightMotor] = 0;
    servo[leftArm] = 10;
    servo[rightArm] = 245;
    bool inCave = false;
    const float length = 250;
    const int speed = 20;
    ClearTimer(T2);
    motor[leftMotor] = speed;
    motor[rightMotor] = speed;
    int lengthC = ceil(((length-5)/31.9185813)*1440);
    while (abs(nMotorEncoder[rightMotor]) <= abs(lengthC) && !inCave && time1[T2] < 10000) {
      if (innerTS()) inCave = true;
    }
  //pack
  servo[leftGoalHolder] = 160;
  if (innerTS()) servo[preloadServo] = 0;
  servo[rightArm] =    0;
  servo[leftArm] =  255;
  while (abs(nMotorEncoder[rightMotor]) <= ceil(((130-5)/31.9185813)*1440)) {
  }
  motor[leftMotor] = 0;
  motor[rightMotor] = 0;
  motor[preloadMotor] = 0;
  servo[leftGoalHolder] = 191;
  int finalDist = ceil((nMotorEncoder[rightMotor]/1440)*31.9185813)+5;
  nMotorEncoder[rightMotor] = 0;
  return finalDist;
}
void getToBridge()
{
      int dist;
    dist = forwardToGoal();
    moveDist(-30, 45);
    wait1Msec(300);
    turnDegrees(30, "right", 60);
    wait1Msec(250);
    straightForTime(30, 1000);
}
float fAngle()
{
  return radiansToDegrees(asin((abs((SensorValue[S3]+2.0)-SensorValue[S4])/18.0)));
}
void die()
{
  while (true)
  {
  }
}
void promptForSide()
{
  eraseDisplay();
  nxtDisplayString(3, "Press Side");
  bool done = false;
  while (!done)
  {
    if (nNxtButtonPressed == 1)
    {
      //chose right side
      rightSide = true;
      done = true;
    }
    else if (nNxtButtonPressed == 2)
    {
      //chose left side
      rightSide = false;
      done = true;
    }
  }
}
  void paralellTurn()
  {
        float angle;
    string s;
    const int usOffset = 2;
    bool error = false;
    while (/*abs((SensorValue[S3]+usOffset)-SensorValue[S4]) >= 3*/ SensorValue[S3]+usOffset != SensorValue[S4] && !error)
    {
      writeDebugStreamLine("[INFO] FUS: %d", SensorValue[S3]);
      writeDebugStreamLine("[INFO] RUS: %d", SensorValue[S4]);
    angle = fAngle();
    if (SensorValue[S3]+usOffset < SensorValue[S4]) s = "right";
    else if (SensorValue[S3]+usOffset > SensorValue[S4]) s = "left";
    else s = "none";
    //ceil(angle/2)
    if (SensorValue[S3] >= 100 || SensorValue[S4] >= 100)
    {
      error = true;
      PlayTone(1000, 150);
      writeDebugStreamLine("[BAD] Error in paralellTurn US values.");
   }
    else turnDegrees(30, s, angle);
    wait1Msec(500);
  }

}
void forwardToWhite(int power = 12)
{
  nMotorEncoder[leftMotor] = 0;
  const int gray = LSvalNorm(msensor_S2_2)+4;
  motor[leftMotor] = power;
  motor[rightMotor] = power;
  ClearTimer(T3);
  while (LSvalNorm(msensor_S2_2) < gray && nMotorEncoder[leftMotor] <= ceil((((80)-5)/31.9185813)*1440) && time1[T3] < 3000 ) {
  }
  motor[leftMotor] = 0;
  motor[rightMotor] = 0;
  nMotorEncoder[leftMotor] = 0;
}

//moveDist([left]power, length, [right]power, coast);
task main()
{
  writeDebugStreamLine("[INFO] New session!");
  initializeRobot();
  ClearTimer(T4);
  //promptForSide();
  waitForStart(); // Wait for the beginning of autonomous phase.
  writeDebugStreamLine("[INFO] Auton. Started");
  //turnDeg(40, "left", 40);
  //SensorValue[S4] >= 200

  if (false)
  {
    int leftEn = 0;
    int rightEn = 0;

    while (true)
  {
    servo[frontUS] = SensorValue[S3];
    servo[rearUS]  = SensorValue[S4];
    eraseDisplay();
    nxtDisplayString(6, "AE: %d", nMotorEncoder[conveyorArmMotor]);
    nxtDisplayString(5, "LE: %d RE: %d", leftEn, rightEn);
    nxtDisplayString(4, "RUS: %d FUS: %d", SensorValue[S4], SensorValue[S3]);
    nxtDisplayString(3, "BLS: %d", LSvalNorm(msensor_S2_2);
    nxtDisplayString(2, "CAngle: %d", fAngle());
    leftEn = nMotorEncoder[leftMotor];
    rightEn = nMotorEncoder[rightMotor];
    writeDebugStreamLine("bottom ls: %d", LSvalNorm(msensor_S2_2));
    writeDebugStreamLine("[INFO] FUS: %d", SensorValue[S3]);
    writeDebugStreamLine("[INFO] RUS: %d", SensorValue[S4]);
    wait1Msec(50);
  }
}
  if (SensorValue[S4] < 200)
  {
    writeDebugStreamLine("[INFO] Running on rt side");
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor]  = 0;
    moveDist(30, 35);
    wait1Msec(200);
    servo[leftArm] = 25;
    periTurn(30, "right", 30);
    servo[rightArm] = 237;
    wait1Msec(400);
    bool inCave = false;
    const float length = 110;
    const int speed = 20;
    ClearTimer(T2);
    motor[leftMotor] = speed;
    motor[rightMotor] = speed;
    int lengthC = ceil(((length-5)/31.9185813)*1440);
    while (abs(nMotorEncoder[leftMotor]) <= abs(lengthC) && !inCave && time1[T2] < 10000) {
      if (innerTS()) inCave = true;
      writeDebugStreamLine("[INFO] Right encoder: %d", nMotorEncoder[rightMotor]);
    }
    //pack
    ClearTimer(T2);
    servo[leftGoalHolder] = 160;
    if (innerTS()) servo[preloadServo] = 0;
    else writeDebugStream("[INFO] Goal not seen in cave, no drop");
    motor[leftMotor] = 15;
    motor[rightMotor] = 15;
    servo[rightArm] =    0;
    servo[leftArm] =  255;
    while (abs(nMotorEncoder[leftMotor]) <= abs(lengthC))
    {
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    motor[preloadMotor] = 0;
    servo[leftGoalHolder] = 191;
    int finalDist = ceil((nMotorEncoder[rightMotor]/1440)*31.9185813)+5;
    nMotorEncoder[rightMotor] = 0;
    wait1Msec(250);
    // out of goal stuff
    moveDist(-30, 57);
    //turn to bridge
    wait1Msec(300);
    periTurn(30, "right", 65);
    wait1Msec(300);
    straightForTime(20, 1500);
    wait1Msec(300);
    moveDist(-25, 20);
    wait1Msec(300);
    servo[rightArm] = 255;
    servo[leftArm] = 0;
    wait1Msec(750);
    moveDist(35, 101);
    wait1Msec(300);
    servo[rightArm] = 0;
    servo[leftArm] = 255;
    wait1Msec(100);
    moveDist(30, 100);
    wait1Msec(200);
    straightForTime(30, 2500);
    while (time1[T4] < 38000) {
    }
    straightForTime(30, 2000);
    die();




    //back off wall
    wait1Msec(300);
    moveDist(-30, 25);
    wait1Msec(300);
    periTurn(30, "right", 95);
    wait1Msec(300);
    paralellTurn();
    wait1Msec(500);
    forwardToWhite(-12);
    die();
}
else if (SensorValue[S4] > 200)
{
    writeDebugStreamLine("[INFO] Running on left side");
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor]  = 0;
    moveDist(30, 35);
    wait1Msec(200);
    servo[rightArm] = 237;
    periTurn(30, "left", 26);
    servo[leftArm] = 25;
    wait1Msec(400);
    bool inCave = false;
    const float length = 110;
    const int speed = 20;
    ClearTimer(T2);
    motor[leftMotor] = speed;
    motor[rightMotor] = speed;
    int lengthC = ceil(((length-5)/31.9185813)*1440);
    while (abs(nMotorEncoder[leftMotor]) <= abs(lengthC) && !inCave && time1[T2] < 10000) {
      if (innerTS()) inCave = true;
      writeDebugStreamLine("[INFO] Right encoder: %d", nMotorEncoder[rightMotor]);
    }
    //pack
    ClearTimer(T2);
    servo[leftGoalHolder] = 160;
    if (innerTS()) servo[preloadServo] = 0;
    motor[leftMotor] = 15;
    motor[rightMotor] = 15;
    servo[rightArm] =    0;
    servo[leftArm] =  255;
    while (abs(nMotorEncoder[leftMotor]) <= abs(lengthC))
    {
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    motor[preloadMotor] = 0;
    servo[leftGoalHolder] = 191;
    int finalDist = ceil((nMotorEncoder[rightMotor]/1440)*31.9185813)+5;
    nMotorEncoder[rightMotor] = 0;
    wait1Msec(250);
    // out of goal stuff
    moveDist(-30, 57);
    //turn to bridge
    wait1Msec(300);
    periTurn(30, "left", 45);
    wait1Msec(300);
    straightForTime(20, 1500);
    wait1Msec(300);
    moveDist(-25, 20);
    wait1Msec(300);
    servo[rightArm] = 255;
    servo[leftArm] = 0;
    wait1Msec(750);
    moveDist(35, 101, 6);
    wait1Msec(300);
    servo[rightArm] = 0;
    servo[leftArm] = 255;
    wait1Msec(100);
    moveDist(30, 100);
    wait1Msec(200);
    straightForTime(30, 2500);
    while (time1[T4] < 38000) {
    }
    straightForTime(30, 2000);
    die();

    //back off wall
    wait1Msec(300);
    moveDist(-30, 25);
    wait1Msec(300);
    periTurn(30, "right", 95);
    wait1Msec(300);
    paralellTurn();
    wait1Msec(500);
    forwardToWhite();
    die();














    turnDegrees(30, "left", 10);
    wait1Msec(150);
    moveDist(-30, 45);
    wait1Msec(300);
    turnDegrees(-30, "right", 50);
    wait1Msec(250);
    straightForTime(30, 1000);
    wait1Msec(150);
    //turnDegrees(30, "right", 10);
    //wait1Msec(200);
    moveDist(-30, 10);
    wait1Msec(200);
    //depress bridge
    servo[rightArm] = 255;
    servo[leftArm]  = 0;
    wait1Msec(1000);
    moveDist(30, 100);
    //raise arms back up halfway on bridge
    servo[leftArm] = 255;
    servo[rightArm] = 10;
    //walk off bridge
    moveDist(30, 115);
    wait1Msec(300);
    //smack into wall
    straightForTime(30, 1000);
    wait1Msec(300);

    die();

    //back off wall
    moveDist(-30, 27);
    wait1Msec(300);
    turnDegrees(30, "right", 90);
    wait1Msec(300);
    paralellTurn();
    wait1Msec(300);
    /*moveDist(-30, 50);
    wait1Msec(300);
    trigMove();
    wait1Msec(300);
    paralellTurn();*/
    wait1Msec(500);
    forwardToWhite();
}

}
