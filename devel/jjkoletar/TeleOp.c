#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTSMUX,              sensorI2CCustom)
#pragma config(Sensor, S3,     front,               sensorSONAR)
#pragma config(Sensor, S4,     back,                sensorSONAR)
#pragma config(Motor,  motorA,          red,           tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          green,         tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          yellow,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     conveyorMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     conveyorArmMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftMotor,     tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     rightMotor,    tmotorNormal, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    rightArm,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    leftArm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    preloadServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    possessionServo,      tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    leftGoalHolder,       tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    unuserdgas,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    frontUS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    rearUS,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    ,                     tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "FITBIncludes.c" //Include multi-purpose custom functions
#include "HTGYRO-driver.h"
#include "LEGOLS-driver.h"
//#include "gyro.c" ///Thanks to Aswin's post at http://www.robotc.net/forums/viewtopic.php?p=11844#p11844

/*   ---FTC--Fish in the Boat Team 4140--Written for CaptureBot v1-- */

int speedFactor;
int speedFactorTurns;
int conveyorPower = 25;
const int deadZone = 5;
bool turnToggle = true;
bool highConveyorPower = true;
bool blinks[3];
const int whiteTape = 35;
const int onMat     = 25;


void defineVariables()
{
  speedFactor = 30;
  speedFactorTurns = 60;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  defineVariables(); //Fix for defining config bugs
  HTSMUXinit();//           Init sensor Muxer
  HTSMUXscanPorts(HTSMUX);//^^^^^^^^^^^^^^^^^
  //init more sensors on the muxer
  LSsetActive(msensor_S2_3); //init goal grabbed lsensor
  LSsetActive(msensor_S2_2); //init lsensor inside goal grabbing area
  LSsetActive(msensor_S2_1);
  LSsetActive(msensor_S2_4);
  servo[possessionServo] = 0;
  servo[rightArm] =    0;
  servo[leftArm] =  255;
  servo[leftGoalHolder] = 190;
  servo[preloadServo] = 255;
  nMotorEncoder[conveyorArmMotor] = 0;
  blinks[0] = false;
  blinks[1] = false;
  blinks[2] = false;
  //robotAdventureTimeDanceTime();
  return;
}



//Light sensor stuff:
/*
High 40s on arm lsensor  = mat
> 50 on arm lsensor = white

50ish on goal sensor = nothing
60s on goal sensor   = goal

*/

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////




void conveyorBelt()
{
  if (joystickVal(2, "x1") < -100) {
    //left high, neg
    highConveyorPower = true;
  }
  else if (joystickVal(2, "x1") > 100)
  {
    //right low, pos
    highConveyorPower = false;
  }
  if (highConveyorPower) conveyorPower = 25;
  else conveyorPower = 15;
  //down/out = pos, in = neg
  if (joystickVal(2, "y1") > deadZone+25 && nMotorEncoder[conveyorArmMotor] > 1000) motor[conveyorMotor] = conveyorPower;
  else if (joystickVal(2, "y1") < deadZone-25 && joystickVal(2, "y1") < 0 && nMotorEncoder[conveyorArmMotor] > 1000) motor[conveyorMotor] = -conveyorPower;
  else motor[conveyorMotor] = 0;
  if (joystickVal(2, "7"))
  {
    //belt down
    /*
    motor[conveyorArmMotor] = 60;
    wait1Msec(250);
    motor[conveyorArmMotor] = 30;
    wait1Msec(1250);
    motor[conveyorArmMotor] = 1;
    wait1Msec(500);
    motor[conveyorArmMotor] = 0;*/
    conveyorOut();
    waitForRelease(2, "7");
  }
  else if (joystickVal(2, "5"))
  {
    //belt up
    //motor[conveyorArmMotor] = -60;
    //wait1Msec(500);
    //motor[conveyorArmMotor] = -40;
    //wait1Msec(1500);
    //motor[conveyorArmMotor] = 1;
    //wait1Msec(500);
    //motor[conveyorArmMotor] = 0;
    //waitForRelease(2, "5");
    //motor[conveyorArmMotor] = -50;
    conveyorIn();


  }
  else motor[conveyorArmMotor] = 0;
}


void speedSections()
{
  if (joystickVal(1, "hat")==6)
  {
    speedFactor = 30;
    speedFactorTurns = 60;
    waitForRelease(1, "6");
  }
  else if (joystickVal(1, "hat")==2)
  {
    speedFactor = 60;
    speedFactorTurns = 100;
    waitForRelease(1, "8");
  }
  else if (joystickVal(1, "hat")==0)
  {
  	//dynamically ++ speed
  	speedFactor = speedFactor + 10;
  	speedFactorTurns = speedFactorTurns + 10;
  	waitForRelease(1, "hat", 0);
  }
  else if (joystickVal(1, "hat")==4)
  {
    // dynamically -- speed
    speedFactor = speedFactor - 10;
    speedFactorTurns = speedFactorTurns - 10;
    waitForRelease(1, "hat", 4);
  }

  if (speedFactor > 100) speedFactor = 100;
  if (speedFactorTurns > 100) speedFactorTurns = 100;

}


void drive()
{
  int finalLeft, finalRight;
  //-128  = all left
  //128  = all right
  //periouette handlers
  if (abs(joystick.joy1_y2) <= deadZone && abs(joystick.joy1_x1) > deadZone && turnToggle)
  {
    //periouette is on
    int perPower = joystick.joy1_x1/128.0*speedFactorTurns;
      //peri
   finalLeft = -perPower;
  finalRight = perPower;
  }
  //drive handlers
  else if (abs(joystick.joy1_y2) > deadZone)
  {
    int drivePower = joystick.joy1_y2/128.0*speedFactor;
    int steering = joystick.joy1_x1/128.0*speedFactor;
    finalLeft = drivePower;
    finalRight = drivePower;
    //left turn handler
    //steering > deadZone
    if (steering > deadZone)
    {
      drivePower = joystick.joy2_y2/128.0*speedFactorTurns;
      steering = joystick.joy2_x1/128.0*speedFactorTurns;
      if (abs(steering) >= abs(drivePower))
      {
        finalLeft = 0;
      }
      else if (drivePower > 0)
      {
        finalLeft -= steering;
      }
      else
      {
        finalLeft += steering;
      }
    }
    //right turn handler
    else if (steering < -deadZone)
    {
      drivePower = joystick.joy2_y2/128.0*speedFactorTurns;
      steering = joystick.joy2_x1/128.0*speedFactorTurns;
      if (abs(steering) >= abs(drivePower))
      {
        finalRight = 0;
      }
      else if (drivePower > 0)
      {
        finalRight += steering;
      }
      else
      {
        finalRight -= steering;
      }
    }
  }
  //stop handler
  else
  {
    finalLeft = 0;
    finalRight = 0;
  }
  //Send to motors
  motor[leftMotor] = finalLeft;
  motor[rightMotor] = finalRight;
}

void driveSwapped()
{
  int finalLeft, finalRight;
  //-128  = all left
  //128  = all right
  //periouette handlers
  if (abs(joystick.joy2_y2) <= deadZone && abs(joystick.joy2_x1) > deadZone && turnToggle)
  {
    //periouette is on
    int perPower = joystick.joy2_x1/128.0*speedFactorTurns;
      //peri
   finalLeft = -perPower;
  finalRight = perPower;
  }
  //drive handlers
  else if (abs(joystick.joy2_y2) > deadZone)
  {
    int drivePower = joystick.joy2_y2/128.0*speedFactor;
    int steering = joystick.joy2_x1/128.0*speedFactor;
    finalLeft = drivePower;
    finalRight = drivePower;
    //left turn handler
    if (steering > deadZone)
    {
      drivePower = joystick.joy2_y2/128.0*speedFactorTurns;
      steering = joystick.joy2_x1/128.0*speedFactorTurns;
      if (abs(steering) >= abs(drivePower))
      {
        finalLeft = 0;
      }
      else if (drivePower > 0)
      {
        finalLeft -= steering;
      }
      else
      {
        finalLeft += steering;
      }
    }
    //right turn handler
    else if (steering < -deadZone)
    {
      drivePower = joystick.joy2_y2/128.0*speedFactorTurns;
      steering = joystick.joy2_x1/128.0*speedFactorTurns;
      if (abs(steering) >= abs(drivePower))
      {
        finalRight = 0;
      }
      else if (drivePower > 0)
      {
        finalRight += steering;
      }
      else
      {
        finalRight -= steering;
      }
    }
  }
  //stop handler
  else
  {
    finalLeft = 0;
    finalRight = 0;
  }
  //Send to motors
  motor[leftMotor] = finalLeft;
  motor[rightMotor] = finalRight;
}




void watchJoySwap()
{
  if ((joystickVal(1, "9") && joystickVal(1, "10")) || (joystickVal(2, "9") && joystickVal(2, "10")))
  {
    wait1Msec(2000);
    if ((joystickVal(1, "9") && joystickVal(1, "10")) || (joystickVal(2, "9") && joystickVal(2, "10"))) swapJoys();
    waitForRelease(1, "9");
    waitForRelease(2, "9");
  }
}


void nudges()
{
  if (joystickVal(1, "4"))
  {
    //forward
    straightForTime(20, 150, true);
    waitForRelease(1, "4");
  }
  else if (joystickVal(1, "2"))
  {
    //backward
    straightForTime(-20, 150, true);
    waitForRelease(1, "2");
  }
  else if (joystickVal(1, "3"))
  {
    //turn right for a lil bit
    motor[rightMotor] = 20;
    wait1Msec(150);
    motor[rightMotor] = 1;
    waitForRelease(1, "3");
  }
  else if (joystickVal(1, "1"))
  {
    //turn left
    motor[leftMotor] = 20;
    wait1Msec(250);
    motor[leftMotor] = 1;
    waitForRelease(1, "1");
  }
  //6 = left, 2 = right
  /*
  !!!!!!!!!!!!!!!!!!!!!!!!
  Deprecated.
  !!!!!!!!!!!!!!!!!!!!!!!!
  else if (joystickVal(1, "hat")==2)
  {
    //jog left
    motor[rightMotor] =40;
    wait1Msec(750);
    motor[rightMotor] = 0;
    motor[leftMotor] = 40;
    wait1Msec(950);
    motor[leftMotor] = 0;
    waitForRelease(1, "hat", 2);
  }
  else if (joystickVal(1, "hat")==6)
  {
    //jog right
    motor[leftMotor] =40;
    wait1Msec(750);
    motor[leftMotor] = 0;
    motor[rightMotor] = 40;
    wait1Msec(950);
    motor[rightMotor] = 0;
    waitForRelease(1, "hat", 6);
  }*/
}


void holdGoalWatcher()
{
  // 180 = on wall
  // 120 = goal on wall
  // tophat 6= left, 2 = right
  // left goal holder
  //if (abs(joystickVal(2, "x1")) > deadZone && joystickVal(2, "x1") < 0) servo[leftGoalHolder] = servo[leftGoalHolder] + 3;
  //else if (abs(joystickVal(2, "x1")) > deadZone && joystickVal(2, "x1") > 0) servo[leftGoalHolder] = servo[leftGoalHolder] -3;
  if (joystickVal(2, "hat") == 6) servo[leftGoalHolder] = 191;
  else if (joystickVal(2, "hat") == 2) servo[leftGoalHolder] = 160;
  // \left goal holder
}

void possessionWatcher()
{

  if (joystickVal(2, "hat")==4)
  {
    //possess goal
    servo[possessionServo] = 140;
    wait1Msec(400);
    //Wait is for packing into back
    servo[possessionServo] = 120;
  }
  else if (joystickVal(2, "hat") == 0)
  {
    //release goal
    servo[possessionServo] = 0;
  }
}

void releasePreloadsWatcher()
{
  if (joystickVal(2, "1"))
  {
    servo[preloadServo] = 255;
  }
  else if (joystickVal(2, "3"))
  {
    servo[preloadServo] = 50;
  }
}

void turnToggleWatcher()
{
  if (joystickVal(1, "11")) turnToggle = !turnToggle;
  waitForRelease(1, "11");
}

void setBlink(string color)
{
  if (color=="red")
  {
    blinks[0] = true;
    blinks[1] = false;
    blinks[2] = false;
  }
  else if (color=="green")
  {
    blinks[0] = false;
    blinks[1] = false;
    blinks[2] = true;
  }
  else if (color=="yellow")
  {
    blinks[0] = false;
    blinks[1] = true;
    blinks[2] = false;
  }
  else if (color=="all")
  {
    blinks[0] = true;
    blinks[1] = true;
    blinks[2] = true;
  }
}


void usLights()
{
  string colorA = "";
  if (SensorValue[S4] == 255) colorA = "all";
  else if (SensorValue[S4] < 30) colorA = "red";
  else if (SensorValue[S4] >= 30 && SensorValue[S4] <= 31) colorA = "green";
  else if (SensorValue[S4] > 32) colorA = "yellow";
  light(colorA);
  if (LSvalNorm(msensor_S2_2) >= whiteTape)
  {
    //setBlink(colorA);
  }
}

void arms()
{
  if (joystickVal(1, "5")) servo[leftArm] = servo[leftArm] + 3;
  else if (joystickVal(1, "7")) servo[leftArm] = servo[leftArm] - 3;

  if (servo[leftArm] <= 25 && !joystickVal(1, "7")) servo[leftArm] = 25;

  if (joystickVal(1, "8")) servo[rightArm] = servo[rightArm] + 3;
  else if (joystickVal(1, "6")) servo[rightArm] = servo[rightArm] - 3;

  //if (servo[rightArm] < 20) servo[rightArm] = 20;
}
void danceWatcher()
{
  if (joystickVal(1, "9") && joystickVal(2, "10"))
  {
  //servo[leftArm] = 0;
  //servo[rightArm] = 0;
  const int amount = 5;
  bool dir = false;
      if (servo[leftArm] == 0 && servo[rightArm] == 0) dir = false;
    else if (servo[leftArm] == 255 && servo[rightArm] == 255) dir = true;
  wait1Msec(750);
  while (joystickVal(1, "9") && joystickVal(2, "10"))
  {
    eraseDisplay();
    nxtDisplayString(3, "Danger Will");
    nxtDisplayString(4, "Robinson!");
    if (!dir)
    {
      //increase left, subtract right
      servo[leftArm] = servo[leftArm] + amount;
      servo[rightArm] = servo[rightArm] + amount;
      wait1Msec(30);
    }
    else if (dir)
    {
      //decrease left, increase right
      servo[leftArm] = servo[leftArm] - amount;
      servo[rightArm] = servo[rightArm] - amount;
      wait1Msec(30);
    }
    if (servo[leftArm] == 0 && servo[rightArm] == 0) dir = false;
    else if (servo[leftArm] == 255 && servo[rightArm] == 255) dir = true;
  }
}
}

void cronAll()
{
    if (swappedJoys()) driveSwapped();
    else drive();
    conveyorBelt();
    speedSections();
    arms();
    watchJoySwap();
    nudges();
    holdGoalWatcher();
    possessionWatcher();
    releasePreloadsWatcher();
    turnToggleWatcher();
    usLights();
    danceWatcher();

}
task blinkLights()
{
  //0 = red, 1 = yellow, 2 = green
  if (blinks[0])
  {
    if (motor[red]==100) motor[red] =   0;
    else if (motor[red]==0)   motor[red] = 100;
  }
  if (blinks[1])
  {
    if (motor[yellow]==100) motor[yellow] =   0;
    else if (motor[yellow]==0)   motor[yellow] = 100;
  }
  if (blinks[2])
  {
    if (motor[green]==100) motor[green] =   0;
    else if (motor[green]==0)   motor[green] = 100;
  }
  //wait1Msec(500);
}

task main()
{
  initializeRobot();
  waitForStart();   // wait for start of tele-op phase
  ClearTimer(T1);
  //StartTask(blinkLights);
  blinks[0] = true;
  blinks[1] = true;
  blinks[2] = true;
  while (true)
  {
    getJoystickSettings(joystick);
    cronAll();
    servo[frontUS] = SensorValue[front];
    servo[rearUS] = SensorValue[back];
  }
}
